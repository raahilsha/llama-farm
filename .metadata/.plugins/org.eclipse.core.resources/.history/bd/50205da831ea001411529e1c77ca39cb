import java.awt.*;

public class Llama
{
	// All possible states a llama can obtain
	// Note that NIRVANA is not among these
	public static Color[] styleColors = {
		new Color(0xFCE4EC),
		new Color(0xF8BBD0),
		new Color(0xF48FB1),
		new Color(0xF06292),
		new Color(0xEC407A),
		new Color(0xE91E63),
		new Color(0xD81B60),
		new Color(0xC2185B),
		new Color(0xAD1457),
		new Color(0x880E4F)
	};
	
	public enum State { IDLE_STATE, FOOD_SEEK, EATING, AGGRESSIVE, ATTACKING, RUNNING_AWAY, RANDOM_WALK, STUNNED }
	
	private GameWorld world;
	private Gene[] genome;
	private double energy;
	
	private double hungerDriveInd, lazinessInd, violenceInd, metabolismInd, styleInd; // This is the order
	
	private State currentState;
	private int cooldown;
	private int xTarget, yTarget;
	
	private int xPos;
	private int yPos;
	
	// Constructor for llama
	public Llama(GameWorld gw, Gene[] g)
	{
		world = gw;
		genome = g;
		currentState = State.IDLE_STATE;
		cooldown = 0;

		hungerDriveInd = g[0].getActivation();
		lazinessInd = g[1].getActivation();
		violenceInd = g[2].getActivation();
		metabolismInd = g[3].getActivation();
		styleInd = g[4].getActivation();
		
		energy = 10000000;

		xPos = (int)(Math.random() * world.getNumTiles());
		yPos = (int)(Math.random() * world.getNumTiles());
	}
	
	// Renders Llama onto game panel based on its stylishness
	public void renderLlama(Graphics img, int tileSize)
	{
		if (styleInd >= 1.0)
			img.setColor(styleColors[9]);
		else
			img.setColor(styleColors[(int)(styleInd * styleColors.length)]);
		
		img.fillOval(xPos * world.getTileSize(), yPos * world.getTileSize(), tileSize - 1, tileSize - 1);
	}
	
	// Breeds one llama with other
	public Llama[] breedWith(Llama other)
	{
		int offspringCount = 4;
		int numGenes = genome.length;
		Gene[] otherGenome = other.getGenome();
		Llama[] offspringLlamas = new Llama[offspringCount];

		Gene[][] finishedChildren = new Gene[numGenes][offspringCount];
		Gene[][] finishedChildrenT = new Gene[offspringCount][numGenes];
		
		// One pass to mate all the genes individually with each other
		for (int i = 0; i < numGenes; i++)
		{
			finishedChildren[i] = genome[i].combineWith(otherGenome[i]);
		}
		
		// Transpose finishedChildren to allow us to extract chains of genes
		for (int r = 0; r < numGenes; r++)
		{
			for (int c = 0; c < offspringCount; c++)
			{
				finishedChildrenT[c][r] = finishedChildren[r][c];
			}
		}
		
		// Place all of the combined genes into new llamas
		for (int i = 0; i < offspringCount; i++)
		{
			offspringLlamas[i] = new Llama(world, finishedChildrenT[i]);
		}
		
		return offspringLlamas;
	}
	
	// Runs the Finite State Machine of Llama
	public void action()
	{
		if (currentState != State.IDLE_STATE)
			energy -= world.getEnergyUse();
		switch (currentState)
		{
			case IDLE_STATE:
				idleAction();
				break;
			case FOOD_SEEK:
				foodSeekAction();
				break;
			case EATING:
				eatAction();
				break;
			case AGGRESSIVE:
				break;
			case ATTACKING:
				break;
			case RUNNING_AWAY:
				break;
			case RANDOM_WALK:
				randWalkAction();
				break;
			case STUNNED:
				stunAction();
				break;
		}
		
		if (energy <= 0)
			die();
	}
	
	private void idleAction()
	{
		if (Math.random() > 1 - (1 - lazinessInd) / 4)
		{
			currentState = State.RANDOM_WALK;
		}
	}
	
	private void stunAction()
	{
		if (cooldown <= 0)
			currentState = State.IDLE_STATE;
		cooldown--;
	}
	
	private void eatAction()
	{
		if (cooldown <= 0)
		{
			world.getMap()[yPos][xPos].changeTile(Tile.TileTypes.SOIL);
			currentState = State.IDLE_STATE;
			energy += 200;
		}
		cooldown--;
	}
	
	private void randWalkAction()
	{
		if (checkIfStunned())
			return;
		if (Math.random() < hungerDriveInd)
		{
			currentState = State.FOOD_SEEK;
			return;
		}
		if (Math.random() < violenceInd)
		{
			// currentState = State.AGGRESSIVE;
			return;
		}
		
		makeRandomMove();
	}
	
	private void foodSeekAction()
	{
		Tile[][] worldMap = world.getMap();
		if (worldMap[yPos][xPos].getType() == Tile.TileTypes.FOOD)
		{
			cooldown = 5;
			currentState = State.EATING;
			return;
		}
		if (checkRecFood(worldMap, xPos, yPos, 5))
		{
			moveTowardsTarget();
		}
		else
		{
			makeRandomMove();
		}
	}
	
	private boolean checkRecFood(Tile[][] worldMap, int xPos2, int yPos2, int i)
	{
		if (i <= 0)
			return false;
		if (outOfBounds(worldMap, xPos2, yPos2))
			return false;
		if (worldMap[yPos2][xPos2].getType() == Tile.TileTypes.FOOD)
		{
			xTarget = xPos2;
			yTarget = yPos2;
			System.out.println(xTarget + " " + yTarget);
			return true;
		}
		
		return checkRecFood(worldMap, xPos2 + 1, yPos2, i - 1) ||
				checkRecFood(worldMap, xPos2 - 1, yPos2, i - 1) ||
				checkRecFood(worldMap, xPos2, yPos2 + 1, i - 1) ||
				checkRecFood(worldMap, xPos2, yPos2 - 1, i - 1);
	}
	
	private boolean checkIfStunned()
	{
		Tile[][] worldMap = world.getMap();
		if (checkRecStunned(worldMap, xPos, yPos, 5))
		{
			currentState = State.STUNNED;
			cooldown = 5;
			return true;
		}
		return false;
	}
	
	public void makeRandomMove()
	{
		int newxPos = -1, newyPos = -1;
		
		while (outOfBounds(world.getMap(), newxPos, newyPos))
		{
			newxPos = ((int)(Math.random() * 3)) - 1 + xPos;
			newyPos = ((int)(Math.random() * 3)) - 1 + yPos;
		}
		
		xPos = newxPos;
		yPos = newyPos;
	}
	
	private boolean checkRecStunned(Tile[][] worldMap, int xPos2, int yPos2, int i)
	{
		if (i <= 0)
			return false;
		if (outOfBounds(worldMap, xPos2, yPos2))
			return false;
		
		Llama otherAtLoc = world.llamaAtLoc(xPos2, yPos2);
		if (otherAtLoc != null)
		{
			double style2 = otherAtLoc.getStylishness();
			if (Math.random() < style2 - styleInd)
				return true;
			else
				return false;
		}
		
		return checkRecStunned(worldMap, xPos2 + 1, yPos2, i - 1) ||
				checkRecStunned(worldMap, xPos2 - 1, yPos2, i - 1) ||
				checkRecStunned(worldMap, xPos2, yPos2 + 1, i - 1) ||
				checkRecStunned(worldMap, xPos2, yPos2 - 1, i - 1);
	}
	
	private boolean outOfBounds(Tile[][] worldMap, int xPos2, int yPos2)
	{
		return xPos2 < 0 || yPos2 < 0 || xPos2 >= worldMap.length || yPos2 >= worldMap.length;
	}
	
	private void moveTowardsTarget()
	{
		if (xPos < xTarget)
			xPos++;
		if (xPos > xTarget)
			xPos--;
		if (yPos < yTarget)
			xPos++;
		if (yPos > yTarget)
			xPos--;
	}

	// Kills the current llama
	public void die()
	{
		world.removeLlama(this);
	}
	
	// Accessor for genome; used when mating
	public Gene[] getGenome()
	{
		return genome;
	}
	
	// Accessor for current state
	public State getState()
	{
		return currentState;
	}
	
	public double getStylishness()
	{
		return styleInd;
	}
	
	public int getX()
	{
		return xPos;
	}
	
	public int getY()
	{
		return yPos;
	}
	
	public String parseState()
	{
		switch (currentState)
		{
			case IDLE_STATE:
				return "Idle";
			case FOOD_SEEK:
				return "Seeking Food";
			case EATING:
				return "Eating Food";
			case AGGRESSIVE:
				return "Aggressive";
			case ATTACKING:
				return "Attacking";
			case RUNNING_AWAY:
				return "Running";
			case RANDOM_WALK:
				return "Random Walk";
			case STUNNED:
				return "Stunned";
		}
		return "State not found";
	}
}
